{"version":3,"sources":["utils/time.js","utils/coinGeckoApi.js","components/DateRangeInputs/DateRangeInputs.jsx","components/DateRangeInputs/index.js","utils/format.js","components/Cards/Cards.jsx","components/Cards/index.js","utils/marketAnalyzer.js","components/MarketChart/config.js","components/MarketChart/MarketChart.jsx","components/MarketChart/index.js","logo.svg","App.jsx","index.js"],"names":["toDateInputValue","time","Date","toISOString","slice","BASE_URL","from","to","a","fetch","response","json","data","prices","oneByDate","volumes","total_volumes","forEach","value","utcDate","toUTCString","toUTCDateString","MIN_DATE","DateRangeInputs","startDate","endDate","onStartDateChange","onEndDateChange","className","htmlFor","id","type","min","max","now","onChange","numberWithSpaces","number","toString","replace","Cards","longestBearishTrend","trendLength","result","Object","entries","index","array","date","price","MarketAnalyzer","highestTradingVolume","reduce","volume","maximumProfit","buyDate","minimumPrice","sellDate","profit","buyingRecommendation","toFixed","Tooltip","positioners","bottom","items","chart","this","_chart","pos","average","x","y","chartArea","config","datasets","label","backgroundColor","borderColor","pointRadius","segment","ctx","p0","parsed","p1","hoverBackgroundColor","yAxisID","options","interaction","intersect","mode","scales","ticks","autoSkipPadding","maxRotation","position","title","display","text","y2","plugins","legend","color","font","family","weight","size","tooltip","xAlign","yAlign","usePointStyle","caretPadding","callbacks","item","dataset","formattedValue","labelPointStyle","pointStyle","elements","point","hoverRadius","MarketChart","canvasRef","useRef","chartRef","useEffect","current","Chart","maintainAspectRatio","destroy","update","ref","INITIAL_START_TIME","initialDate","setMonth","getMonth","getTime","oneMonthBefore","INITIAL_END_TIME","App","useState","startTime","setStartTime","endTime","setEndTime","setPrices","setVolumes","fetchBitcoinMarketData","then","src","logo","width","height","alt","e","target","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6fdc9931.chunk.js","sourcesContent":["// Converts time in ms to date input value format\nexport function toDateInputValue(time) {\n  return new Date(time).toISOString().slice(0, 10);\n}\n\n// Converts time in ms to date string in UTC time\nexport function toUTCDateString(time) {\n  return new Date(time).toUTCString().slice(5, 16);\n}\n\n// Given time in ms returns relative time one month before\nexport function oneMonthBefore(time) {\n  const initialDate = new Date(time);\n  initialDate.setMonth(initialDate.getMonth() - 1);\n  return initialDate.getTime();\n}\n","import { toUTCDateString } from './time';\n\nconst BASE_URL =\n  'https://api.coingecko.com/api/v3/coins/bitcoin/market_chart/range';\n\n/*\n * Fetches bitcoin market data between from and to times in milliseconds.\n * Returns an object with prices and volumes properties.\n * Prices and volumes are returned as objects containing one entry for each day.\n */\nexport async function fetchBitcoinMarketData(from, to) {\n  var response = await fetch(\n    `${BASE_URL}?vs_currency=eur&from=${from / 1000}&to=${to / 1000 + 3600}`\n  );\n\n  var data = await response.json();\n\n  return {\n    prices: oneByDate(data.prices),\n    volumes: oneByDate(data.total_volumes),\n  };\n}\n\n/*\n * Converts data array with entries in format of [time, value] to an object\n * which has only one entry per day. Other entries are discarded.\n * The iterating order of the data array is preserved and the first seen entry\n * for one day is always selected.\n */\nfunction oneByDate(data) {\n  var oneByDate = {};\n  data.forEach(([time, value]) => {\n    let utcDate = toUTCDateString(time);\n    oneByDate[utcDate] = oneByDate[utcDate] || value;\n  });\n  return oneByDate;\n}\n","import { toDateInputValue } from '../../utils/time';\nimport './DateRangeInputs.css';\n\n// First date that the CoinGecko market API has data of Bitcoin\nconst MIN_DATE = '2013-04-28';\n\nfunction DateRangeInputs({\n  startDate,\n  endDate,\n  onStartDateChange,\n  onEndDateChange,\n}) {\n  return (\n    <div className=\"date-inputs\">\n      <div className=\"input-group\">\n        <label htmlFor=\"fromInput\">Start date</label>\n        <input\n          id=\"fromInput\"\n          type=\"date\"\n          value={startDate}\n          min={MIN_DATE}\n          max={toDateInputValue(Date.now())}\n          onChange={onStartDateChange}\n        />\n      </div>\n      <div className=\"input-group\">\n        <label htmlFor=\"toInput\">End date</label>\n        <input\n          id=\"toInput\"\n          type=\"date\"\n          value={endDate}\n          min={MIN_DATE}\n          max={toDateInputValue(Date.now())}\n          onChange={onEndDateChange}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default DateRangeInputs;\n","import DateRangeInputs from './DateRangeInputs';\n\nexport default DateRangeInputs;\n","// Formats long numbers delimiting them by spaces after every 3 numbers\nexport function numberWithSpaces(number) {\n  return number.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ' ');\n}\n","import { numberWithSpaces } from '../../utils/format';\nimport * as MarketAnalyzer from '../../utils/marketAnalyzer';\nimport './Cards.css';\n\nfunction Cards({ prices, volumes }) {\n  // Calculate stats about current prices and volumes\n  var longestBearishTrend = MarketAnalyzer.longestBearishTrend(prices);\n  var highestTradingVolume = MarketAnalyzer.highestTradingVolume(volumes);\n  var maximumProfit = MarketAnalyzer.maximumProfit(prices);\n\n  // Depending if there is profit to be made, show different text for bying recommendation\n  var buyingRecommendation = maximumProfit.buyDate\n    ? `If bought on ${maximumProfit.buyDate} and sold\n      on ${maximumProfit.sellDate}`\n    : `Bitcoins should not be bought on the selected date range`;\n\n  return (\n    <div className=\"cards\">\n      <div className=\"card\">\n        <h3 className=\"card-title\">Longest bearish trend</h3>\n        <p className=\"card-focal\">{longestBearishTrend.trendLength} days</p>\n        <p>\n          {longestBearishTrend.startDate} - {longestBearishTrend.endDate}\n        </p>\n      </div>\n      <div className=\"card\">\n        <h3 className=\"card-title\">Highest trading volume</h3>\n        <p className=\"card-focal\">\n          {numberWithSpaces(highestTradingVolume.volume.toFixed(0))} €\n        </p>\n        <p>{highestTradingVolume.date}</p>\n      </div>\n      <div className=\"card\">\n        <h3 className=\"card-title\">Maximum profit</h3>\n        <p className=\"card-focal\">\n          {numberWithSpaces(maximumProfit.profit.toFixed(2))} € / BTC\n        </p>\n        <p>{buyingRecommendation}</p>\n      </div>\n    </div>\n  );\n}\n\nexport default Cards;\n","import Cards from './Cards';\n\nexport default Cards;\n","/*\n * Given prices object with one entry per day iteration ordered by day\n * calculates longest bearish (downward) trend for the prices.\n * Returns start date, end date and length of the longest trend\n */\nexport function longestBearishTrend(prices) {\n  var result = {\n    startDate: null,\n    endDate: null,\n    trendLength: 0,\n  };\n\n  var startDate, endDate, trendLength;\n\n  Object.entries(prices).forEach(([date, price], index, array) => {\n    // If at first entry or previous day price was lower than current day price\n    // initialize start date to current date and trend length to zero\n    if (index === 0 || price >= array[index - 1][1]) {\n      startDate = date;\n      trendLength = 0;\n      return;\n    }\n\n    // Otherwise bearish trend continues\n    trendLength++;\n    endDate = date;\n\n    // If currently observed trend is longer than longest already seen trend\n    // Update result accordingly\n    if (trendLength > result.trendLength) {\n      result = {\n        startDate,\n        endDate,\n        trendLength,\n      };\n    }\n  });\n\n  return result;\n}\n\n/*\n * Gets the day and volume of the given volumes object with one entry per day\n */\nexport function highestTradingVolume(volumes) {\n  var result = {\n    date: null,\n    volume: 0,\n  };\n\n  // Reducer function to find out the day and volume of the highest volume entry\n  function highestVolumeReducer(result, [date, volume]) {\n    return volume > result.volume ? { date, volume } : result;\n  }\n\n  return Object.entries(volumes).reduce(highestVolumeReducer, result);\n}\n\n/*\n * Given prices object with one entry per day iteration ordered by day\n * calculates maximum profit for the prices.\n * Returns buy date, sell date and maximum profit\n */\nexport function maximumProfit(prices) {\n  var result = {\n    buyDate: null,\n    sellDate: null,\n    profit: 0,\n  };\n\n  var buyDate, minimumPrice;\n\n  Object.entries(prices).forEach(([date, price], index) => {\n    // If at first index or even lower buying price than current lowest is found\n    // Update min price and buying date accordingly\n    if (index === 0 || price < minimumPrice) {\n      minimumPrice = price;\n      buyDate = date;\n      return;\n    }\n\n    // Otherwise calculate profit if item was bought with min price and sold with current price\n    const profit = price - minimumPrice;\n\n    // If profit is higher than highest seen profit, update result accordingly\n    if (profit > result.profit) {\n      result = {\n        buyDate,\n        sellDate: date,\n        profit,\n      };\n    }\n  });\n\n  return result;\n}\n","import { Tooltip } from 'chart.js';\n\n// Custom tooltip positioner\nTooltip.positioners.bottom = function (items) {\n  const chart = this._chart;\n  const pos = Tooltip.positioners.average(items);\n\n  return pos\n    ? {\n        x: pos.x,\n        y: chart.chartArea.bottom,\n      }\n    : false;\n};\n\n// Configuration of the chart, check chart.js docs\nconst config = {\n  data: {\n    datasets: [\n      {\n        label: 'Price',\n        type: 'line',\n        backgroundColor: 'rgb(242, 169, 0)',\n        borderColor: 'rgb(242, 169, 0)',\n        pointRadius: '0',\n        segment: {\n          borderColor: (ctx) =>\n            ctx.p0.parsed.y < ctx.p1.parsed.y\n              ? 'rgb(0, 255, 0)'\n              : 'rgb(255, 0, 0)',\n        },\n      },\n      {\n        label: 'Volume',\n        backgroundColor: 'rgb(0, 0, 0, 0.2)',\n        hoverBackgroundColor: 'rgb(0, 0, 0, 0.6)',\n        type: 'bar',\n        yAxisID: 'y2',\n      },\n    ],\n  },\n  options: {\n    interaction: {\n      intersect: false,\n      mode: 'index',\n    },\n    scales: {\n      x: {\n        ticks: {\n          autoSkipPadding: 12,\n          maxRotation: 30,\n        },\n      },\n      y: {\n        type: 'linear',\n        position: 'left',\n        title: {\n          display: true,\n          text: 'Price [€ / BTC]',\n        },\n      },\n      y2: {\n        type: 'linear',\n        position: 'right',\n        title: {\n          display: true,\n          text: 'Volume [€]',\n        },\n      },\n    },\n    plugins: {\n      legend: {\n        display: false,\n      },\n      title: {\n        display: true,\n        text: 'Daily price and trading volume of Bitcoin',\n        color: 'black',\n        font: {\n          family: '\"Ubuntu\", sans-serif',\n          weight: 'bold',\n          size: 18,\n        },\n      },\n      tooltip: {\n        position: 'bottom',\n        xAlign: 'center',\n        yAlign: 'bottom',\n        usePointStyle: true,\n        caretPadding: 4,\n        callbacks: {\n          label: (item) => `${item.dataset.label} ${item.formattedValue} €`,\n          labelPointStyle: () => ({\n            pointStyle: 'circle',\n          }),\n        },\n      },\n    },\n    elements: {\n      point: {\n        hoverRadius: '6',\n      },\n    },\n  },\n};\n\nexport default config;\n","import './MarketChart.css';\nimport Chart from 'chart.js/auto';\nimport { useEffect, useRef } from 'react';\nimport config from './config';\n\nfunction MarketChart({ prices, volumes }) {\n  // Reference for the canvas html element\n  var canvasRef = useRef();\n  // Reference for current chart instance\n  var chartRef = useRef();\n\n  // On mount init chart instance\n  useEffect(() => {\n    chartRef.current = new Chart(canvasRef.current, config);\n    chartRef.current.options.maintainAspectRatio = false;\n    // On unmount destroy current chart instance\n    return () => chartRef.current.destroy();\n  }, []);\n\n  // Update chart datasets when prices or volumes are updated\n  useEffect(() => {\n    chartRef.current.data.datasets[0].data = prices;\n    chartRef.current.data.datasets[1].data = volumes;\n    chartRef.current.update();\n  }, [prices, volumes]);\n\n  return (\n    <div className=\"chart-container\">\n      <canvas ref={canvasRef}></canvas>\n    </div>\n  );\n}\n\nexport default MarketChart;\n","import MarketChart from './MarketChart';\n\nexport default MarketChart;\n","export default __webpack_public_path__ + \"static/media/logo.229e5f10.svg\";","import { useEffect, useState } from 'react';\nimport { fetchBitcoinMarketData } from './utils/coinGeckoApi';\nimport { oneMonthBefore, toDateInputValue } from './utils/time';\nimport DateRangeInputs from './components/DateRangeInputs';\nimport Cards from './components/Cards';\nimport MarketChart from './components/MarketChart';\nimport logo from './logo.svg';\nimport './App.css';\n\n// When the App loads, start time is set to one month before current time\nconst INITIAL_START_TIME = oneMonthBefore(Date.now());\n// And end time is set to current time\nconst INITIAL_END_TIME = Date.now();\n\nfunction App() {\n  // Start time of the date range as milliseconds\n  var [startTime, setStartTime] = useState(INITIAL_START_TIME);\n  // End time of the date range as milliseconds\n  var [endTime, setEndTime] = useState(INITIAL_END_TIME);\n  // Price market data of bitcoin in the selected date range\n  var [prices, setPrices] = useState({});\n  // Volume market data of bitcoin in the selected date range\n  var [volumes, setVolumes] = useState({});\n\n  // Load new bitcoin market data, when the start or end time of the date range changes\n  useEffect(() => {\n    fetchBitcoinMarketData(startTime, endTime).then(({ prices, volumes }) => {\n      setPrices(prices);\n      setVolumes(volumes);\n    });\n  }, [startTime, endTime]);\n\n  function onStartDateChange(e) {\n    setStartTime(new Date(e.target.value).getTime() || INITIAL_START_TIME);\n  }\n\n  function onEndDateChange(e) {\n    setEndTime(new Date(e.target.value).getTime() || INITIAL_END_TIME);\n  }\n\n  return (\n    <div>\n      <header className=\"header\">\n        <img src={logo} width=\"60\" height=\"60\" alt=\"Bitcoin Icon\" />\n        <h1>Bitcoin Market Analyzer</h1>\n      </header>\n\n      <main>\n        <h2 className=\"section-title\">The date range to be analyzed</h2>\n        <DateRangeInputs\n          startDate={toDateInputValue(startTime)}\n          endDate={toDateInputValue(endTime)}\n          onStartDateChange={onStartDateChange}\n          onEndDateChange={onEndDateChange}\n        />\n        <Cards prices={prices} volumes={volumes} />\n        <MarketChart prices={prices} volumes={volumes} />\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}